<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>Cosmic Pepe: Dubstep Dodge</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <style>
        @import url('https://fonts.googleapis.com/css2?family=Press+Start+2P&display=swap');
        body { margin: 0; overflow: hidden; background: #050505; touch-action: none; font-family: 'Press Start 2P', cursive; user-select: none; -webkit-user-select: none; }
        canvas { display: block; }
        .ui-layer { position: absolute; top: 0; left: 0; width: 100%; height: 100%; pointer-events: none; display: flex; flex-direction: column; justify-content: center; align-items: center; }
        .interactive { pointer-events: auto; }
        .glitch { position: relative; color: #0f0; font-size: 2rem; animation: glitch-anim 0.3s infinite; }
        @keyframes glitch-anim {
            0% { transform: translate(0) }
            20% { transform: translate(-2px, 2px) }
            40% { transform: translate(-2px, -2px) }
            60% { transform: translate(2px, 2px) }
            80% { transform: translate(2px, -2px) }
            100% { transform: translate(0) }
        }
        .hidden { display: none !important; }
        
        /* Custom scrollbar */
        .leaderboard-list::-webkit-scrollbar { width: 6px; }
        .leaderboard-list::-webkit-scrollbar-track { background: #111; }
        .leaderboard-list::-webkit-scrollbar-thumb { background: #0f0; border-radius: 3px; }
        
        .bass-pulse { animation: pulse 0.4s ease-out; }
        @keyframes pulse {
            0% { transform: scale(1.05); text-shadow: 0 0 20px #0f0; }
            100% { transform: scale(1); text-shadow: none; }
        }
    </style>
</head>
<body>

    <!-- Game Canvas -->
    <canvas id="gameCanvas"></canvas>

    <!-- UI: Start Screen -->
    <div id="startScreen" class="ui-layer bg-black/80 z-50 interactive backdrop-blur-sm">
        <h1 id="titleText" class="text-green-500 text-3xl md:text-6xl mb-4 text-center drop-shadow-[0_0_10px_rgba(0,255,0,0.8)] tracking-widest">COSMIC PEPE</h1>
        <p class="text-white text-xs md:text-sm mb-8 text-center max-w-md leading-6 px-4 opacity-80">
            DODGE OBJECTS. FEEL THE BASS.<br>
            <span class="text-yellow-400">BEST EXPERIENCED WITH HEADPHONES</span>
        </p>
        <button id="startBtn" class="bg-green-600 hover:bg-green-500 text-black font-bold py-4 px-8 rounded border-b-4 border-green-800 active:border-b-0 active:translate-y-1 transition-all shadow-[0_0_15px_rgba(0,255,0,0.5)]">
            INITIATE DROP
        </button>
    </div>

    <!-- UI: HUD -->
    <div id="hud" class="ui-layer !justify-start !items-start p-4 hidden z-40">
        <div class="flex flex-col gap-2">
            <div class="text-green-400 text-lg shadow-black drop-shadow-md">SCORE: <span id="scoreDisplay">0</span></div>
            <div class="text-red-400 text-xs">MULTIPLIER: <span id="multiplierDisplay">1.0x</span></div>
        </div>
    </div>

    <!-- UI: Game Over -->
    <div id="gameOverScreen" class="ui-layer bg-black/90 z-50 interactive hidden backdrop-blur-md overflow-y-auto py-8">
        <h2 class="text-red-500 text-3xl md:text-5xl mb-2 glitch">WASTED</h2>
        <p class="text-white mb-2">FINAL SCORE: <span id="finalScore" class="text-green-400">0</span></p>
        
        <!-- AI Comment Section -->
        <div id="aiCommentBox" class="text-yellow-300 text-xs md:text-sm mb-6 max-w-md text-center italic min-h-[40px] px-4">
            Generating cosmic wisdom...
        </div>

        <div class="bg-gray-900 p-4 rounded-lg border border-green-900 w-full max-w-md mx-4 shadow-2xl mb-4">
            <h3 class="text-green-500 text-center mb-4 text-xs border-b border-green-900 pb-2 tracking-wider">GALACTIC LEADERBOARD</h3>
            
            <div id="leaderboardList" class="leaderboard-list h-32 overflow-y-auto text-xs mb-4 space-y-2 font-mono bg-black/50 p-2 rounded">
                <div class="text-gray-500 text-center animate-pulse">Connecting to Deep Space Network...</div>
            </div>

            <div class="flex gap-2" id="inputContainer">
                <input type="text" id="playerName" placeholder="PILOT NAME" maxlength="8" class="bg-black border border-green-700 text-green-500 px-3 py-2 w-full text-xs focus:outline-none focus:border-green-400 uppercase font-mono">
                <button id="submitScoreBtn" class="bg-green-700 hover:bg-green-600 text-white px-4 py-2 text-xs whitespace-nowrap font-bold">UPLOAD</button>
            </div>
        </div>

        <button id="restartBtn" class="mt-2 bg-transparent border-2 border-white text-white hover:bg-white hover:text-black font-bold py-3 px-6 transition-colors text-sm tracking-wider">
            RETRY MISSION
        </button>
    </div>

    <!-- Firebase Libraries -->
    <script type="module">
        import { initializeApp } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-app.js";
        import { getAuth, signInAnonymously, signInWithCustomToken, onAuthStateChanged } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-auth.js";
        import { getFirestore, collection, addDoc, getDocs, serverTimestamp } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-firestore.js";

        // --- CONFIGURATION ---
        let firebaseConfig;
        try {
            const urlParams = new URLSearchParams(window.location.search);
            const urlConfig = urlParams.get('firebase_config');
            if (urlConfig) firebaseConfig = JSON.parse(urlConfig);
        } catch (e) { console.warn("Error parsing URL config:", e); }

        if (!firebaseConfig && typeof __firebase_config !== 'undefined') {
            try { firebaseConfig = JSON.parse(__firebase_config); } 
            catch (e) { console.error("Error parsing global config:", e); }
        }

        const appId = typeof __app_id !== 'undefined' ? __app_id : 'default-app-id';

        // --- FIREBASE INIT ---
        let app = null;
        let auth = null;
        let db = null;
        let currentUser = null;
        let firebaseEnabled = false;

        // Only initialize Firebase if we have a valid config with required properties
        if (firebaseConfig && firebaseConfig.apiKey) {
            try {
                app = initializeApp(firebaseConfig);
                auth = getAuth(app);
                db = getFirestore(app);
                firebaseEnabled = true;

                const initAuth = async () => {
                     try {
                        if (typeof __initial_auth_token !== 'undefined' && __initial_auth_token) {
                            await signInWithCustomToken(auth, __initial_auth_token);
                        } else {
                            await signInAnonymously(auth);
                        }
                     } catch (e) {
                         console.error("Auth Error:", e);
                     }
                };
                initAuth();

                onAuthStateChanged(auth, (user) => {
                    currentUser = user;
                    if(user) loadLeaderboard();
                });
            } catch (e) {
                console.error("Firebase initialization error:", e);
                firebaseEnabled = false;
            }
        } else {
            console.log("Firebase not configured - running in offline mode");
        }

        // --- LEADERBOARD LOGIC ---
        const leaderboardList = document.getElementById('leaderboardList');
        const submitBtn = document.getElementById('submitScoreBtn');
        const nameInput = document.getElementById('playerName');
        const inputContainer = document.getElementById('inputContainer');

        async function loadLeaderboard() {
            if (!firebaseEnabled || !currentUser || !db) {
                leaderboardList.innerHTML = '<div class="text-gray-600 text-center mt-8">SECTOR CLEAR. NO RECORDS. (OFFLINE MODE)</div>';
                return;
            }
            try {
                const querySnapshot = await getDocs(collection(db, 'artifacts', appId, 'public', 'data', 'leaderboard'));
                const scores = [];
                querySnapshot.forEach((doc) => {
                    const data = doc.data();
                    if (typeof data.score === 'number' && data.name) {
                        scores.push(data);
                    }
                });

                scores.sort((a, b) => b.score - a.score);
                const top10 = scores.slice(0, 20);

                leaderboardList.innerHTML = top10.map((s, i) => `
                    <div class="flex justify-between items-center p-1 ${i === 0 ? 'text-yellow-400 font-bold' : 'text-gray-400'} border-b border-gray-800 hover:bg-white/5">
                        <span>${i+1}. ${escapeHtml(s.name)}</span>
                        <span>${Math.floor(s.score).toLocaleString()}</span>
                    </div>
                `).join('');

                if (top10.length === 0) {
                    leaderboardList.innerHTML = '<div class="text-gray-600 text-center mt-8">SECTOR CLEAR. NO RECORDS.</div>';
                }
            } catch (e) {
                leaderboardList.innerHTML = '<div class="text-red-500 text-center mt-8">UPLINK FAILED. OFFLINE MODE.</div>';
            }
        }

        submitBtn.addEventListener('click', async () => {
            const name = nameInput.value.trim() || "UNKNOWN";
            const score = Math.floor(game.score);
            if (!firebaseEnabled || !currentUser || !db) {
                submitBtn.textContent = "OFFLINE";
                setTimeout(() => {
                    submitBtn.textContent = "UPLOAD";
                    submitBtn.disabled = false;
                }, 2000);
                return;
            }
            submitBtn.textContent = "...";
            submitBtn.disabled = true;
            try {
                await addDoc(collection(db, 'artifacts', appId, 'public', 'data', 'leaderboard'), {
                    name: name.substring(0, 10).toUpperCase(),
                    score: score,
                    uid: currentUser.uid,
                    timestamp: serverTimestamp()
                });
                inputContainer.classList.add('hidden');
                await loadLeaderboard();
                submitBtn.textContent = "SENT";
            } catch (e) {
                console.error("Error saving score", e);
                submitBtn.textContent = "ERR";
                setTimeout(() => submitBtn.disabled = false, 2000);
            }
        });

        function escapeHtml(text) {
            const div = document.createElement('div');
            div.textContent = text;
            return div.innerHTML;
        }

        // --- GEMINI API INTEGRATION ---
        const apiKey = ""; // Injected at runtime

        async function generateDeathMessage(score) {
            const commentBox = document.getElementById('aiCommentBox');
            commentBox.textContent = "Contacting Pepe's spirit...";
            
            const prompt = `You are Pepe the Frog. I just died in a space game with a score of ${score}. Give me a very short, funny, roast-style comment (max 15 words) about my performance. Be snarky.`;

            try {
                const response = await fetch(`https://generativelanguage.googleapis.com/v1beta/models/gemini-2.5-flash-preview-09-2025:generateContent?key=${apiKey}`, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({
                        contents: [{ parts: [{ text: prompt }] }]
                    })
                });

                if (!response.ok) throw new Error('Gemini API Error');

                const data = await response.json();
                const text = data.candidates?.[0]?.content?.parts?.[0]?.text || "Feels bad man.";
                commentBox.textContent = `"${text}"`;
            } catch (error) {
                console.error("Gemini Error:", error);
                commentBox.textContent = "Feels bad man. (Connection Lost)";
            }
        }

        // --- AUDIO SYSTEM ---
        class AudioEngine {
            constructor() {
                this.ctx = null;
                this.isPlaying = false;
                this.tempo = 140;
                this.nextNoteTime = 0;
                this.beatCount = 0;
            }

            init() {
                const AudioContext = window.AudioContext || window.webkitAudioContext;
                this.ctx = new AudioContext();
                this.masterGain = this.ctx.createGain();
                this.masterGain.gain.value = 0.3;
                this.masterGain.connect(this.ctx.destination);
                if(this.ctx.state === 'suspended') this.ctx.resume();
                this.isPlaying = true;
                this.nextNoteTime = this.ctx.currentTime + 0.1;
                this.scheduler();
            }

            scheduler() {
                if (!this.isPlaying) return;
                while (this.nextNoteTime < this.ctx.currentTime + 0.1) {
                    this.playBeat(this.nextNoteTime, this.beatCount);
                    const secondsPerBeat = 60.0 / this.tempo;
                    this.nextNoteTime += secondsPerBeat * 0.5; 
                    this.beatCount++;
                }
                setTimeout(() => this.scheduler(), 25);
            }

            playBeat(time, beat) {
                const step = beat % 16;
                if (step === 0 || step === 6 || step === 10) {
                    this.kick(time);
                    if (step === 0 || step === 10) setTimeout(() => { game.pulse = 15; }, (time - this.ctx.currentTime) * 1000);
                }
                if (step === 4 || step === 12) this.snare(time);
                if (step % 2 === 0) this.hihat(time, step % 4 === 0 ? 0.15 : 0.05);
                if (step < 16) {
                    let rate = 3, freq = 55;
                    if (step >= 0 && step < 4) rate = 3;
                    if (step >= 4 && step < 8) { rate = 6; freq = 55; }
                    if (step >= 8 && step < 12) { rate = 12; freq = 41.2; }
                    if (step >= 12) { rate = 8; freq = 55; }
                    this.wobbleBass(time, 0.5 * (60/140), rate, freq);
                }
            }

            kick(time) {
                const osc = this.ctx.createOscillator();
                const gain = this.ctx.createGain();
                osc.connect(gain);
                gain.connect(this.masterGain);
                osc.frequency.setValueAtTime(150, time);
                osc.frequency.exponentialRampToValueAtTime(0.01, time + 0.5);
                gain.gain.setValueAtTime(1, time);
                gain.gain.exponentialRampToValueAtTime(0.01, time + 0.5);
                osc.start(time);
                osc.stop(time + 0.5);
            }

            snare(time) {
                const bufferSize = this.ctx.sampleRate * 0.5;
                const buffer = this.ctx.createBuffer(1, bufferSize, this.ctx.sampleRate);
                const data = buffer.getChannelData(0);
                for (let i = 0; i < bufferSize; i++) data[i] = Math.random() * 2 - 1;
                const noise = this.ctx.createBufferSource();
                noise.buffer = buffer;
                const noiseFilter = this.ctx.createBiquadFilter();
                noiseFilter.type = 'highpass';
                noiseFilter.frequency.value = 1500;
                const noiseEnv = this.ctx.createGain();
                noise.connect(noiseFilter);
                noiseFilter.connect(noiseEnv);
                noiseEnv.connect(this.masterGain);
                noiseEnv.gain.setValueAtTime(0.7, time);
                noiseEnv.gain.exponentialRampToValueAtTime(0.01, time + 0.2);
                noise.start(time);
                noise.stop(time + 0.2);
            }

            hihat(time, vol) {
                const bufferSize = this.ctx.sampleRate * 0.1;
                const buffer = this.ctx.createBuffer(1, bufferSize, this.ctx.sampleRate);
                const data = buffer.getChannelData(0);
                for (let i = 0; i < bufferSize; i++) data[i] = Math.random() * 2 - 1;
                const noise = this.ctx.createBufferSource();
                noise.buffer = buffer;
                const filter = this.ctx.createBiquadFilter();
                filter.type = 'highpass';
                filter.frequency.value = 10000;
                const gain = this.ctx.createGain();
                noise.connect(filter);
                filter.connect(gain);
                gain.connect(this.masterGain);
                gain.gain.setValueAtTime(vol, time);
                gain.gain.exponentialRampToValueAtTime(0.01, time + 0.05);
                noise.start(time);
                noise.stop(time + 0.05);
            }

            wobbleBass(time, duration, lfoRate, freq) {
                const osc = this.ctx.createOscillator();
                osc.type = 'sawtooth';
                osc.frequency.value = freq;
                const filter = this.ctx.createBiquadFilter();
                filter.type = 'lowpass';
                filter.Q.value = 10;
                const gain = this.ctx.createGain();
                const lfo = this.ctx.createOscillator();
                lfo.type = 'sine';
                lfo.frequency.value = lfoRate;
                const lfoGain = this.ctx.createGain();
                lfoGain.gain.value = 1500;
                lfo.connect(lfoGain);
                lfoGain.connect(filter.frequency);
                osc.connect(filter);
                filter.connect(gain);
                gain.connect(this.masterGain);
                filter.frequency.setValueAtTime(800, time); 
                gain.gain.setValueAtTime(0, time);
                gain.gain.linearRampToValueAtTime(0.5, time + 0.05);
                gain.gain.linearRampToValueAtTime(0.5, time + duration - 0.05);
                gain.gain.linearRampToValueAtTime(0, time + duration);
                osc.start(time);
                lfo.start(time);
                osc.stop(time + duration);
                lfo.stop(time + duration);
            }

            stop() {
                this.isPlaying = false;
                if (this.ctx) { this.ctx.close(); this.ctx = null; }
            }
        }

        // --- GAME ENGINE ---
        const canvas = document.getElementById('gameCanvas');
        const ctx = canvas.getContext('2d');

        function resize() {
            canvas.width = window.innerWidth;
            canvas.height = window.innerHeight;
        }
        window.addEventListener('resize', resize);
        resize();

        const game = {
            running: false,
            loopId: null,
            score: 0,
            multiplier: 1,
            speed: 5,
            time: 0,
            pulse: 0,
            player: { x: 0, y: 0, size: 20, angle: 0 },
            mouse: { x: canvas.width/2, y: canvas.height/2 },
            enemies: [],
            particles: [],
            stars: []
        };

        const updateInput = (x, y) => {
            game.mouse.x = x;
            game.mouse.y = y;
        };
        window.addEventListener('mousemove', e => updateInput(e.clientX, e.clientY));
        window.addEventListener('touchmove', e => {
            e.preventDefault();
            updateInput(e.touches[0].clientX, e.touches[0].clientY);
        }, { passive: false });
        window.addEventListener('touchstart', e => {
             updateInput(e.touches[0].clientX, e.touches[0].clientY);
        }, { passive: false });

        // --- UPDATED PEPE SUPERMAN DRAWING ---
        function drawPepe(x, y, size, angle) {
            ctx.save();
            ctx.translate(x, y);
            // Calculate rotation based on movement vector, slightly smoothed
            ctx.rotate(angle);
            
            const scale = 1 + (game.pulse / 100);
            ctx.scale(scale, scale);

            // Cape (Behind)
            ctx.fillStyle = '#e3242b'; // Red Cape
            ctx.beginPath();
            // Flapping logic using sin wave
            const flap = Math.sin(game.time * 20) * 5;
            ctx.moveTo(-size * 0.8, -size * 0.3);
            ctx.lineTo(-size * 2.5, -size * 0.8 + flap); // Tail of cape top
            ctx.lineTo(-size * 2.5, size * 0.8 + flap);  // Tail of cape bottom
            ctx.lineTo(-size * 0.8, size * 0.3);
            ctx.closePath();
            ctx.fill();

            // Body (Oval)
            ctx.fillStyle = '#4a9c2d'; // Pepe Green
            ctx.beginPath();
            ctx.ellipse(-size * 0.2, 0, size * 0.9, size * 0.4, 0, 0, Math.PI * 2);
            ctx.fill();
            ctx.strokeStyle = '#367520';
            ctx.lineWidth = 2;
            ctx.stroke();

            // Head (Slightly forward)
            ctx.save();
            ctx.translate(size * 0.3, -size * 0.2);
            
            ctx.fillStyle = '#4a9c2d';
            ctx.beginPath();
            ctx.ellipse(0, 0, size * 0.6, size * 0.5, 0, 0, Math.PI * 2);
            ctx.fill();
            ctx.stroke();

            // Eyes
            const eyeSize = size * 0.25;
            const eyeOffset = size * 0.3;
            
            ctx.fillStyle = 'white';
            ctx.beginPath();
            ctx.arc(0, -eyeSize, eyeSize, 0, Math.PI * 2); // Left (actually top in side view)
            ctx.fill();
            ctx.stroke();
            
            ctx.fillStyle = 'black';
            ctx.beginPath();
            ctx.arc(size * 0.1, -eyeSize, size * 0.08, 0, Math.PI * 2);
            ctx.fill();
            
            // Eyelids (chill)
            ctx.fillStyle = '#4a9c2d';
            ctx.beginPath();
            ctx.arc(0, -eyeSize, eyeSize + 1, Math.PI * 1.1, Math.PI * 1.9);
            ctx.fill();
            ctx.stroke();

            // Mouth (Smirk)
            ctx.strokeStyle = '#8b0000';
            ctx.lineWidth = 2;
            ctx.beginPath();
            ctx.moveTo(-size*0.2, size*0.2);
            ctx.quadraticCurveTo(0, size*0.3, size*0.2, size*0.1);
            ctx.stroke();
            
            ctx.restore(); // End head

            // Arm (Superman outstretched)
            ctx.fillStyle = '#4a9c2d';
            ctx.beginPath();
            ctx.ellipse(size * 0.8, 0, size * 0.6, size * 0.15, 0, 0, Math.PI * 2);
            ctx.fill();
            ctx.stroke();
            
            // Fist
            ctx.fillStyle = '#4a9c2d';
            ctx.beginPath();
            ctx.arc(size * 1.4, 0, size * 0.2, 0, Math.PI * 2);
            ctx.fill();
            ctx.stroke();

            ctx.restore();
        }

        function drawAsteroid(e) {
            ctx.fillStyle = '#666';
            ctx.strokeStyle = '#444';
            ctx.lineWidth = 3;
            ctx.beginPath();
            const sides = 7;
            for(let i=0; i<sides; i++) {
                const angle = (i/sides) * Math.PI * 2;
                const r = e.radius * (0.8 + Math.sin(angle * 5 + e.id) * 0.2);
                const x = e.x + Math.cos(angle + game.time * 0.5) * r;
                const y = e.y + Math.sin(angle + game.time * 0.5) * r;
                if(i===0) ctx.moveTo(x, y);
                else ctx.lineTo(x, y);
            }
            ctx.closePath();
            ctx.fill();
            ctx.stroke();
        }

        function drawHunter(e) {
            ctx.save();
            ctx.translate(e.x, e.y);
            ctx.rotate(game.time * 8);
            ctx.fillStyle = '#ff3333';
            ctx.shadowColor = '#ff0000';
            ctx.shadowBlur = 15;
            ctx.beginPath();
            const r = e.radius;
            ctx.moveTo(r, 0);
            ctx.lineTo(-r * 0.5, r * 0.8);
            ctx.lineTo(-r * 0.2, 0);
            ctx.lineTo(-r * 0.5, -r * 0.8);
            ctx.closePath();
            ctx.fill();
            ctx.shadowBlur = 0;
            ctx.restore();
        }

        for(let i=0; i<120; i++) {
            game.stars.push({
                x: Math.random() * canvas.width,
                y: Math.random() * canvas.height,
                z: Math.random() * 2 + 0.2,
                size: Math.random() * 2
            });
        }

        let audioEngine = null;

        function startGame() {
            if (game.running) return;
            if (game.loopId) cancelAnimationFrame(game.loopId);

            document.getElementById('startScreen').classList.add('hidden');
            document.getElementById('gameOverScreen').classList.add('hidden');
            document.getElementById('hud').classList.remove('hidden');
            
            if (audioEngine) audioEngine.stop();
            audioEngine = new AudioEngine();
            audioEngine.init();

            // RESET GAME STATE
            game.running = true;
            game.score = 0;
            game.speed = 4;
            game.multiplier = 1;
            game.enemies = [];
            game.particles = [];
            game.player.x = canvas.width / 2;
            game.player.y = canvas.height / 2;
            
            // Input reset
            document.getElementById('inputContainer').classList.remove('hidden');
            submitBtn.textContent = "UPLOAD";
            submitBtn.disabled = false;

            loop();
        }

        function gameOver() {
            game.running = false;
            if (audioEngine) {
                const now = audioEngine.ctx.currentTime;
                audioEngine.masterGain.gain.exponentialRampToValueAtTime(0.001, now + 1);
                setTimeout(() => {
                    if (audioEngine) audioEngine.stop();
                    audioEngine = null;
                }, 1000);
            }

            document.getElementById('hud').classList.add('hidden');
            document.getElementById('gameOverScreen').classList.remove('hidden');
            document.getElementById('finalScore').textContent = Math.floor(game.score).toLocaleString();
            
            loadLeaderboard();
            // Call Gemini
            generateDeathMessage(Math.floor(game.score));
        }

        function spawnEnemy() {
            const difficulty = 1 + (game.score / 2000);
            const maxEnemies = 4 + Math.floor(game.score / 600);
            if (game.enemies.length >= Math.min(maxEnemies, 25)) return;

            const isHunter = Math.random() > 0.75;
            const radius = isHunter ? 15 : 25 + Math.random() * 30;
            const speed = isHunter ? game.speed * 1.3 : game.speed;

            const margin = 100;
            let x, y;
            if (Math.random() > 0.5) {
                x = Math.random() > 0.5 ? -margin : canvas.width + margin;
                y = Math.random() * canvas.height;
            } else {
                x = Math.random() * canvas.width;
                y = Math.random() > 0.5 ? -margin : canvas.height + margin;
            }

            const angle = Math.atan2(game.player.y - y, game.player.x - x);
            const spread = (Math.random() - 0.5) * 0.5;
            
            game.enemies.push({
                id: Math.random(),
                type: isHunter ? 'hunter' : 'asteroid',
                x: x, y: y,
                vx: Math.cos(angle + spread) * speed,
                vy: Math.sin(angle + spread) * speed,
                radius: radius
            });
        }

        function createExplosion(x, y, color) {
            for(let i=0; i<20; i++) {
                game.particles.push({
                    x: x, y: y,
                    vx: (Math.random() - 0.5) * 15,
                    vy: (Math.random() - 0.5) * 15,
                    life: 1.0,
                    color: color
                });
            }
        }

        function loop() {
            if (!game.running) return;

            game.time += 0.016;
            game.score += 0.5 * game.multiplier;
            game.speed = 5 + (game.score / 2000); 
            if (game.pulse > 0) game.pulse -= 1;

            const dx = game.mouse.x - game.player.x;
            const dy = game.mouse.y - game.player.y;
            game.player.x += dx * 0.12;
            game.player.y += dy * 0.12;
            // Angle follows velocity
            game.player.angle = Math.atan2(dy, dx);

            const bgOpacity = 0.2 + (game.pulse / 60);
            ctx.fillStyle = `rgba(5, 5, 5, 0.5)`;
            ctx.fillRect(0, 0, canvas.width, canvas.height);

            ctx.fillStyle = '#fff';
            game.stars.forEach(star => {
                const boost = 1 + (game.pulse / 10);
                star.x -= star.z * (game.speed / 2) * boost;
                if (star.x < 0) {
                    star.x = canvas.width;
                    star.y = Math.random() * canvas.height;
                }
                const size = star.size + (game.pulse / 10);
                ctx.globalAlpha = Math.random() * 0.8 + 0.2;
                ctx.beginPath();
                ctx.arc(star.x, star.y, size, 0, Math.PI*2);
                ctx.fill();
            });
            ctx.globalAlpha = 1.0;

            if (Math.random() < 0.04) spawnEnemy();

            for (let i = game.enemies.length - 1; i >= 0; i--) {
                const e = game.enemies[i];
                e.x += e.vx;
                e.y += e.vy;

                if (e.type === 'hunter') {
                    const angle = Math.atan2(game.player.y - e.y, game.player.x - e.x);
                    e.vx += Math.cos(angle) * 0.15;
                    e.vy += Math.sin(angle) * 0.15;
                    const v = Math.sqrt(e.vx*e.vx + e.vy*e.vy);
                    const maxV = game.speed * 1.5;
                    if (v > maxV) {
                        e.vx = (e.vx/v) * maxV;
                        e.vy = (e.vy/v) * maxV;
                    }
                }

                if (e.type === 'asteroid') drawAsteroid(e);
                else drawHunter(e);

                const dist = Math.hypot(game.player.x - e.x, game.player.y - e.y);
                // Hitbox adjustment for superhero pose
                const hitDist = (game.player.size * 0.6) + (e.radius * 0.8);
                
                if (dist < hitDist) {
                    createExplosion(game.player.x, game.player.y, '#4a9c2d');
                    gameOver();
                    return; 
                }

                if (e.x < -200 || e.x > canvas.width + 200 || e.y < -200 || e.y > canvas.height + 200) {
                    game.enemies.splice(i, 1);
                }
            }

            for (let i = game.particles.length - 1; i >= 0; i--) {
                const p = game.particles[i];
                p.x += p.vx;
                p.y += p.vy;
                p.life -= 0.03;
                
                ctx.fillStyle = p.color;
                ctx.globalAlpha = Math.max(0, p.life);
                ctx.beginPath();
                ctx.arc(p.x, p.y, 3 + Math.random()*2, 0, Math.PI*2);
                ctx.fill();
                
                if (p.life <= 0) game.particles.splice(i, 1);
            }
            ctx.globalAlpha = 1.0;

            drawPepe(game.player.x, game.player.y, game.player.size + 12, game.player.angle);

            document.getElementById('scoreDisplay').textContent = Math.floor(game.score);
            document.getElementById('multiplierDisplay').textContent = game.multiplier.toFixed(1) + 'x';

            game.loopId = requestAnimationFrame(loop);
        }

        document.getElementById('startBtn').addEventListener('click', startGame);
        document.getElementById('restartBtn').addEventListener('click', startGame);
        
        const titleText = document.getElementById('titleText');
        titleText.addEventListener('mouseenter', () => {
            titleText.classList.add('glitch');
        });
        titleText.addEventListener('mouseleave', () => {
            titleText.classList.remove('glitch');
        });

    </script>
</body>
</html>